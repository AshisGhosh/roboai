#!/usr/bin/env python3

"""Run robot simulations to generate images and collect metadata.

This script automates the process of running robot simulations to generate images & collect metadata
about the objects in the simulated environment. It interacts with a server to start, run, and close
simulations, fetch images, and retrieve object details. The script saves the images and metadata
for each simulation run and aggregates the metadata into a single JSON file.

Usage:
    python3 robot_simulation.py [-n RUNS] [-d]

Arguments:
    -n, --runs (optional): Number of simulation runs to perform (default: 50).
    -d, --disable_mirror (optional): Disable mirroring of images.

The script creates a directory for each batch of simulation runs, named with a timestamp. Inside
each directory, it saves images generated during the simulations and metadata about the objects
detected in those images. The metadata includes information such as object names, poses, and
quaternions. Also, the script records the start time and duration of the batch of simulations
and includes this information in the aggregated metadata.

The run information is saved in a JSON file named after the directory where the images are stored.
"""


import datetime
import hashlib
import json
import os
import httpx
from PIL import Image
import argparse
import trimesh
import numpy as np

# Base path to the data directory containing STL files
BASE_DATA_PATH = os.path.join(os.path.dirname(__file__), 'data')

# Dictionary mapping object names to STL filenames
stl_files = {
    "Bread": "bread.stl",
    "Cereal": "cereal.stl",
    "Milk": "milk.stl",
    "Can": "can.stl"
}

# Preload meshes
meshes = {
    name: trimesh.load(os.path.join(BASE_DATA_PATH, filename))
    for name, filename in stl_files.items()
}

def start_simulation(sim_number):
    print(f"[Sim {sim_number}] Starting the simulation...")
    with httpx.Client() as client:
        response = client.post("http://localhost:8000/start")
    if response.is_success:
        print(f"[Sim {sim_number}] Simulation started successfully.")
        return datetime.datetime.now().timestamp()
    else:
        print(f"[Sim {sim_number}] Failed to start simulation.")
    return None

def close_simulation(sim_number, start_time):
    print(f"[Sim {sim_number}] Closing the simulation...")
    with httpx.Client() as client:
        response = client.post("http://localhost:8000/close")
    if response.is_success:
        end_time = datetime.datetime.now().timestamp()
        print(f"[Sim {sim_number}] Simulation closed successfully.")
        return end_time - start_time
    else:
        print(f"[Sim {sim_number}] Failed to close simulation.")
    return None

def get_image(sim_number, image_path):
    print(f"[Sim {sim_number}] Fetching image to save at {image_path}...")
    with httpx.Client() as client:
        response = client.get("http://localhost:8000/get_image")
    if response.is_success:
        with open(image_path, "wb") as f:
            f.write(response.content)
        print(f"[Sim {sim_number}] Image fetched and saved successfully.")
        return True
    print(f"[Sim {sim_number}] Failed to fetch image.")
    return False

def create_base_folder():
    script_directory = os.path.dirname(os.path.realpath(__file__))
    expected_directory_suffix = 'roboai/shared'  
    if not script_directory.endswith(expected_directory_suffix):
        raise RuntimeError(f"This script should be run from a directory ending with '{expected_directory_suffix}', but is running from '{script_directory}'.")
    image_exports_directory = os.path.join(script_directory, 'data', 'image_exports')
    if not os.path.exists(image_exports_directory):
        os.makedirs(image_exports_directory)
        print(f"Image exports directory created at {image_exports_directory}")
    # Create a specific directory for this run based on the current timestamp
    folder_name = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    run_directory = os.path.join(image_exports_directory, folder_name)
    os.makedirs(run_directory, exist_ok=True)
    print(f"Created directory for this run: {run_directory}")
    # Update the 'latest' symlink to point to the newly created folder
    latest_symlink_path = os.path.join(image_exports_directory, 'latest')
    if os.path.lexists(latest_symlink_path):
        os.unlink(latest_symlink_path)  # Remove existing symlink if it exists
    os.symlink(folder_name, latest_symlink_path)  # Create new symlink
    print(f"Updated 'latest' symlink to point to: {folder_name}")
    return run_directory, folder_name

def flip_images(sim_number, directory, filename):
    print(f"[Sim {sim_number}] Flipping image {filename}...")
    image_path = os.path.join(directory, filename)
    img = Image.open(image_path)
    img_flipped = img.transpose(Image.FLIP_LEFT_RIGHT)
    flipped_filename = f"{filename.split('.')[0]}_flipped.png"
    img_flipped.save(os.path.join(directory, flipped_filename))
    print(f"[Sim {sim_number}] Image flipping complete.")

def apply_transformation(object_name, position, quaternion, size):
    """Apply transformation and scale to a preloaded mesh and return the transformed mesh."""
    mesh = meshes[object_name].copy()
    mesh.apply_scale(size)
    transformation_matrix = trimesh.transformations.quaternion_matrix(quaternion)
    transformation_matrix[:3, 3] = position
    mesh.apply_transform(transformation_matrix)
    return mesh

def get_metadata(sim_number):
    """Calls for object position information and then uses raytracing to get distances between objects"""
    print(f"[Sim {sim_number}] Fetching object details and generating metadata...")
    with httpx.Client() as client:
        response = client.get("http://localhost:8000/get_object_details")
    
    if not response.is_success:
        print(f"[Sim {sim_number}] Failed to fetch object details or empty metadata.")
        return None

    objects = response.json()
    if not objects:
        return None

    transformed_meshes = {}
    for obj in objects:
        transformed_meshes[obj['name']] = apply_transformation(obj['name'], obj['pose'], obj['quaternion'], obj['size'])

    for obj in objects:
        obj['distances'] = {}
        origin_mesh = transformed_meshes[obj['name']]
        for other_obj in objects:
            if obj['name'] == other_obj['name']:
                continue
            target_mesh = transformed_meshes[other_obj['name']]
            origins = np.array(origin_mesh.vertices)
            directions = target_mesh.centroid - origins
            directions /= np.linalg.norm(directions, axis=1)[:, np.newaxis]

            intersector = trimesh.ray.ray_triangle.RayMeshIntersector(target_mesh)
            intersections = intersector.intersects_location(origins, directions)
            distances = np.linalg.norm(intersections[0] - origins[intersections[1]], axis=1) if intersections[0].size > 0 else np.inf

            obj['distances'][other_obj['name']] = distances.min() if distances.size > 0 else np.inf

    return objects

def parse_arguments():
    parser = argparse.ArgumentParser(description="Run robot simulations to generate and optionally mirror images.")
    parser.add_argument("-n", "--runs", type=int, default=50, help="Number of simulation runs (default: 50)")
    parser.add_argument("-d", "--disable_mirror", action="store_true", help="Disable mirroring of images")
    return parser.parse_args()

def format_timestamp(unix_time):
    """Converts UNIX timestamp to a human-readable format."""
    return datetime.datetime.fromtimestamp(unix_time).strftime("%Y-%m-%d %H:%M:%S")

def generate_unique_id(batch_start_time):
    """Generates a unique ID based on the batch start time."""
    unique_string = f"batch_{batch_start_time}"
    return hashlib.sha256(unique_string.encode()).hexdigest()

def construct_json_output(run_info, num_simulations, disable_mirror, batch_start_time, batch_end_time):
    """Construct the final JSON output containing all runs and batch information."""
    batch_duration = batch_end_time - batch_start_time
    batch_info = {
        "uid": generate_unique_id(batch_start_time),
        "runs": num_simulations,
        "disable_mirror": disable_mirror,
        "batch_start_time": format_timestamp(batch_start_time),
        "batch_end_time": format_timestamp(batch_end_time),
        "duration": batch_duration
    }
    return {
        "batch_info": batch_info,
        "runs": run_info
    }

def main():
    args = parse_arguments()
    num_simulations = args.runs
    disable_mirror = args.disable_mirror
    base_folder, folder_name = create_base_folder()

    batch_start_time = datetime.datetime.now().timestamp()  # Record batch start time using datetime
    run_info = []  # List to store metadata for each run

    for sim_number in range(1, num_simulations + 1):
        start_time = start_simulation(sim_number)
        if start_time:
            image_filename = f"{sim_number:02}.png"
            image_path = os.path.join(base_folder, image_filename)
            if get_image(sim_number, image_path):
                if not disable_mirror:
                    flip_images(sim_number, base_folder, image_filename)
                metadata = get_metadata(sim_number)
                if metadata:
                    run_info.append({
                        "run": sim_number,
                        "image_file": image_filename,
                        "objects": metadata
                    })
            time_taken = close_simulation(sim_number, start_time)
            if time_taken:
                print(f"[Sim {sim_number}] Time taken for simulation: {time_taken:.2f} seconds")

    batch_end_time = datetime.datetime.now().timestamp()  # Record batch end time using datetime

    final_output = construct_json_output(run_info, num_simulations, disable_mirror, batch_start_time, batch_end_time)

    # Save final_output to a JSON file in the batch folder
    json_filename = os.path.join(base_folder, f"{folder_name}.json")
    with open(json_filename, "w") as f:
        json.dump(final_output, f, indent=4)
    print(f"Run info saved to {json_filename}")

if __name__ == "__main__":
    main()
